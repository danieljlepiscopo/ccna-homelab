# IP ACLs and Security Services

Securing networks and making sure that filters are in place to help ensure that packets travel to the correct destination are imperative in modern enterprise networks. In this lab, we will break these topics up into five different sections and end with a wrap-up:

1. **Basic Standard IPv4 ACLs**
2. **Named ACLs**
3. **Extended ACLs**
4. **Practical ACLs for my Homelab**
5. **Security Services**
6. **Wrap-Up**

Standard IPv4 Access Control Lists (ACLs) are the most basic form of ACLs that Cisco offers; however, in more modern networks, they have been replaced with named and Extended ACLs, allowing for more varied header fields in each Access Control Entry (ACE). Once we complete those sections, we will move on to the last section that covers several different topics: port security, DHCP snooping, and Dynamic ARP Inspection (DAI). Let’s get started!

## **Basic Standard IPv4 ACLs**

IPv6 ACLs are used to help network engineers identify different packets in a network and help control where they are allowed and not allowed to traverse the network. My L3 switch is the perfect place to start. Let’s configure a simple host block on SW1 to prevent my PC from talking to my Ubuntu VM on SW2:

For testing purposes, let’s ping the Ubuntu VM from my Windows PC, just to show that they are pingable before the configuration is set:

<center>
  <img width="400" height="500" alt="sw1_default_desktop" class="center" src="https://github.com/user-attachments/assets/0544bcb9-43d1-48cd-9da4-a6dd2f0d439f" />
</center>

<center>
  <img width="400" height="500" alt="sw1_default_desktop" class="center" src="https://github.com/user-attachments/assets/7d42efbc-8d79-451c-8eb2-c1aab3c5dbea" />
</center>

- Since we created the DHCP pool on SW1, the Ubuntu VM will get a new IPv4 address dynamically. As of now, it’s `192.168.10.12`. We can ping it from my PC, which is `192.168.1.10`.

Now, let’s add the ACL configuration on SW1:

**SW1**

```bash
conf t
!
access-list 10 deny host 192.168.1.10
access-list 10 permit any
!
interface vlan 10
 ip access-group 10 out
exit
!
end
wr
```

Let’s break down these commands:

- `access-list`: Global command to define an ACL ACE.
- `10`: ACL number (1 - 99 is standard, 100 - 199 is extended).
- `deny host 192.168.1.10`: Denies only this specific host (Windows 11 PC).
- `permit any`:  Allows everything else (this needed to be added, or the ACL will add an **implicit deny all** command automatically, denying all traffic).

After that, we then just apply the interface subcommand access-group to VLAN 10 for all “out” traffic going out of the interface, blocking PC1.

**Verify**

```bash
clear access-list counters
show access-lists
show ip interface vlan 10
```

- From these verification commands, we will see that the ACL configuration is set.

From here, if we try to ping the Ubuntu VM from my Windows 11 PC, it will come back received, but untunetly blocked:

<center>
  <img width="400" height="500" alt="sw1_default_desktop" class="center" src="https://github.com/user-attachments/assets/9000eebe-8a70-4914-92df-0019314b7ecd" />
</center>

<center>
  <img width="400" height="500" alt="sw1_default_desktop" class="center" src="https://github.com/user-attachments/assets/158da83a-803e-46af-b622-d990962c984a" />
</center>

**Standard IPv4 ACL Removal**

Let’s go ahead and delete this ACL on SW1 and replace it with a similar functioning named ACL next:

**SW1**

```bash
conf t
!
no access-list 10
!
interface vlan 10
 no ip access-group 10 out
exit
!
end
wr
```

If we try to ping the Ubuntu VM again on the Windows 10 PC, it should go through now :

<center>
  <img width="400" height="500" alt="sw1_default_desktop" class="center" src="https://github.com/user-attachments/assets/fb2d4978-bf5a-41b9-86d9-7e397d03c36b" />
</center>

- This concept applies to the next ACL configuration, so I won’t show screenshots.

Although Basic Standard IPv4 ACLs aren’t the most preferred way of working on ACLs for network engineers, they are still used in enterprise networks. Understanding how to use, reconfigure, and delete them is crucial for any network position. Next up, let’s take a look at the needed upgrade for Standard ACLs: **Named ACLs**.

## Named ACLs

Standard ACLs were great, but they were difficult to edit. To make any changes, you had to reconfigure the entire ACL to add a new ACE (ACL statement), which is risky in a production environment. In the 2000s, Cisco created **Named ACLs** that can be applied to either **Standard ACLs** or **Extended ACLs**.

The name difference is in the ability to create specific ACLs for different filters, which can be applied through the ACL configuration mode. Let’s apply the same blocking PC1 ACL we did in the standard ACL section, but create it as a Named ACL:

**SW1**

```bash
conf t
!
ip access-list standard BLOCK_PC1
 deny host 192.168.1.10
 permit any
exit
!
interface vlan 10
 ip access-group BLOCK_PC1 out
exit
!
end
wr
```

Let’s break down these commands:

- `ip access-list standard BLOCK_PC1`: Starts ACL configuration mode, as we’re giving it a name of “BLOCK_PC1”.
- `deny host 192.168.1.10`: Similar to before, we are denying this single host.
- `permit any`: Allows all other traffic.
- `ip access-group BLOCK_PC1 out`: Adding the ACL filter of BLOCK_PC1 to all the “out” traffic of VLAN 10.

As you can see, this is a much newer and easier way to manage numbered ACLs, allowing us to not globally configure the ACL, but just configure it on the ACL we create. Let’s verify really quickly:

**Verify**

```bash
clear access-list counters
show access-lists
show ip interface vlan 10
```

**Named ACL Removal**
With everything coming back normally, let’s also remove this named ACL:

SW1

```bash
conf t
!
no ip access-list standard BLOCK_PC1
!
interface vlan 20
 no ip access-group BLOCK_PC1 in
exit
!
end
wr
```

Named ACLs allow you to be more specific when it comes to ACLs, and it’s a great foreshadowing moment for our next section, Extended ACLs. Allowing you even more specification when it comes to allowing or denying protocols, source/destination IPs, and source/destination ports. This is where modern enterprise networks showcase these ACLs!

## Extended ACLs

**Extended ACLs** work just like Standard IP ACLs; the only difference is that Extended ACLs can match multiple header fields in a single ACE. That means that just one extended ACE (ACL statement) can examine multiple parts of the packet headers, so that every parameter has to match the packet for the ACL to consider the packet an ACE match. If it isn’t more noticeable now, Extended ACLs are incredibly more complex than standard IP ACLs.

To introduce Extended ACLs, let’s make this as simple as possible; let’s create a simple **HTTP traffic** ACL from VLAN 20 to VLAN 10 to only allow HTTP traffic, block everything else:

**SW1**

```bash
conf t
!
ip access-list extended VLAN10_HTTP_ONLY
 permit tcp 192.168.20.0 0.0.0.255 192.168.10.0 0.0.0.255 eq 80
 deny ip any any
exit
!
interface vlan 20
 ip access-group VLAN10_HTTP_ONLY in
exit
!
end
wr
```

Let’s break down these commands:

- `ip access-list extended VLAN10_HTTP_ONLY`: Starts extended ACL configuration mode, as we’re giving it a name of “VLAN10_HTTP_ONLY”.
- `permit tcp`: Allow TCP traffic (since HTTP uses TCP).
- `192.168.20.0 0.0.0.255`: Source subnet + VLAN20’s wildcard mask (WC is the inverse of subnet mask).
- `192.168.10.0 0.0.0.255`: Destination subnet (VLAN 10) + wildcard mask.
- `eq 80`: Matches only to traffic going to TCP port 80 (HTTP).
- `deny ip any any`: Explicitly blocks all other IP traffic.
- `ip access-group VLAN10_HTTP_ONLY in`: Adding the ACL filter of VLAN10_HTTP_ONLY to all the “in” traffic of VLAN 20.

Although it’s a lot to digest, it adds a lot of specificity to the ACL, making it more powerful when it comes to source and destination end-hosts. Let’s check that the ACL works:

**Verify**

```bash
clear access-list counters
show access-lists
show ip interface vlan 20
```

- With everything coming back normally, let's test it.

**Extended ACL VM Testing**

To test this, we can create a basic web server on the Ubuntu VM and then see if we can reach it on the Windows 10 VM. Here’s how.
**Ubuntu VM**

```bash
sudo python3 -m http.server 80
```

- With this command, we’re creating a basic HTTP server on port 80.

**Windows 10 VM**

```bash
curl [http://192.168.10.12](http://192.168.10.12/)
```

- Here we are using the `curl` command to see the basic web server that we created on the Ubuntu VM

Alternatively, you can also just open a browser (Edge/Chrome/Firefox) and visit the Ubuntu VM:

```bash
[http://192.168.10.12](http://192.168.10.12/)
```

If everything works properly, you should see ping traffic filtered, but you should be able to access the HTTP web server from the Windows 10 VM:

**Ubuntu VM**

<center>
  <img width="400" height="500" alt="sw1_default_desktop" class="center" src="https://github.com/user-attachments/assets/18c61c71-8382-4567-a26b-108ce8592177" />
</center>

**Windows VM**

<center>
  <img width="400" height="500" alt="sw1_default_desktop" class="center" src="https://github.com/user-attachments/assets/2961ac9c-ee60-4faf-8616-a93dccd3a6c0" />
</center>

<center>
  <img width="400" height="500" alt="sw1_default_desktop" class="center" src="https://github.com/user-attachments/assets/251945cb-ef30-4e71-9ed7-c19dd8ec38c2" />
</center>

After that, we should be good! ICMP from ping isn’t working, but HTTP (port 80) works without a problem between the VMs. Next, let’s go ahead and remove this filter.
**Extended ACL Removal**
We can go ahead and remove the extended ACL now:

```bash
conf t
!
no ip access-list extended VLAN10_HTTP_ONLY
!
interface vlan 20
 no ip access-group VLAN10_HTTP_ONLY in
exit
!
end
wr

```

All of this is well and good for understanding ACLs, but it’s difficult to apply ACLs in a homelab without end-host traffic, right? Well, yes and no. For the examples we’ve done, yes, however, there are network infrastructure protocols we can apply filters to in the homelab to secure, such as: DNS, ICMP, routing protocols (like OSPF), DHCP, and SSH/Telnet.

## Practical ACLs for my Homelab

ACLs’ difficulty doesn’t come from their configurations, but rather their applicability to many different networking environment protocols. Let’s go over several protocols that we can apply to help showcase the complexity of ACLs, as well as make the homelab more “enterprise-friendly” with ACLs that can work without end-host connectivity.

### SSH/Telnet Restriction

Let’s secure SSH/Telnet by only allowing the `192.168.1.0/24` management VLAN to log in to devices. We will apply this to every IOS device.

**SW1/SW2/SW3/R1/R2/R3**

```bash
conf t
!
ip access-list standard MGMT_VTY
 permit 192.168.1.0 0.0.0.255
 deny  any
exit
!
line vty 0 4
 access-class MGMT_VTY in
 transport input ssh
 exec-timeout 15 0
 login local
exit
!
ip ssh version 2
 no ip http server
 no ip http secure-server
!
end
wr
```

Command Breakdown:

- `ip access-list standard MGMT_VTY`: Standard ACL listing who can open VTY sessions.
- `permit 192.168.1.0 0.0.0.255`: Only hosts in the MGMT subnet can connect.
- `deny any`: Blocks anyone else trying to connect.
- `line vty … / access-class MGMT_VTY in`: Applies the ACL to any incoming VTY sessions.
- `transport input ssh`: Disables Telnet to only use SSH.
- `login local`: Uses local username/password (be sure you’ve configured.
- `ip ssh version 2`: Forces SSHv2 (more secure).

**Verify**

```bash
show access-lists MGMT_VTY
show run | sec line vty
show ip ssh
show users
```

Now that we have SSH/Telnet secured, any non-mgmt subnet host will fail to SSH/Telnet into any of the devices. Next, let's take a look at ICMP.

### ICMP Control

For ICMP, let's limit ICMP for internal troubleshooting only. This way, only the `192.168.1.0/24` management can ping into VLAN 10 and VLAN 20, but it will block cross-VLAN pings. 

We’ll also only apply this to outbound traffic, so traffic only destined to those specific VLANs.

**SW1**

```bash
conf t
!
ip access-list extended ICMP_MGMT_ONLY
 remark Allow mgmt to ping into VLAN 10 & 20; block other inter-VLAN ICMP
 permit icmp 192.168.1.0 0.0.0.255 192.168.10.0 0.0.0.255 echo
 permit icmp 192.168.1.0 0.0.0.255 192.168.20.0 0.0.0.255 echo
 deny   icmp any any
 permit ip any any
exit
!
interface vlan 10
 ip access-group ICMP_MGMT_ONLY out
exit
!
interface vlan 20
 ip access-group ICMP_MGMT_ONLY out
exit
!
end
wr
```

Command Breakdown:

- `ip access-list extended ICMP_MGMT_ONLY`: Extended ACL name that describes its purpose.
- `remark …` : A note that will show up to describe what the ACL does.
- `permit icmp 192.168.1.0 0.0.0.255 192.168.10.0 0.0.0.255 echo`: Allows echo requests (pings) from MGMT (VLAN99) to VLAN10.
- `permit icmp 192.168.1.0 0.0.0.255 192.168.20.0 0.0.0.255 echo`: Allows echo requests (pings) from MGMT (VLAN99) to VLAN20.
- `deny icmp any any`: Blocks all other ICMP traffic, even between VLAN10 and VLAN20.
- `permit ip any any`: Filtering only ICMP, making sure everything else routes normally.
- `ip access-group ICMP_MGMT_ONLY out`: Applied to the egress on destination SVI, VLAN10, and VLAN20, traffic is routed and exited out on SVI 10/20. This is where the ACL evaluates the ICMP echo request and either permits or denies it.

**Verify**

```bash
show ip access-lists ICMP_MGMT_ONLY
show ip interface vlan 10 | inc access list
show ip interface vlan 20 | inc access list
```

With ICMP secured, we’re able to ping the default gateways from the Ubuntu and Windows 10 VMs, but not each other. Next up, let’s take a look at protecting OSPF.

### OSPF Protection

Permitting OSPF only on the router interconnects, while blocking OSPF on user VLANs, helps to protect hosts from forming adjacencies by accident. We will configure all of the routers, their P2P interfaces, and then we’ll add an ACL on SW1 to deny any OSPF on the SVIs. 

**R1**

```bash
conf t
!
ip access-list extended OSPF_R1_R2
 10 permit ospf host 192.168.3.1 host 224.0.0.5
 20 permit ospf host 192.168.3.2 host 224.0.0.5
 30 permit ospf host 192.168.3.1 host 224.0.0.6
 40 permit ospf host 192.168.3.2 host 224.0.0.6
 50 permit ospf host 192.168.3.1 host 192.168.3.2
 60 permit ospf host 192.168.3.2 host 192.168.3.1
 70 deny   ospf any any
 80 permit ip any any
exit
!
interface Gi0/0
 ip access-group OSPF_R1_R2 in
exit
!
end
wr
```

R2

```bash
conf t
!
ip access-list extended OSPF_R2_R1
 10 permit ospf host 192.168.3.2 host 224.0.0.5
 20 permit ospf host 192.168.3.1 host 224.0.0.5
 30 permit ospf host 192.168.3.2 host 224.0.0.6
 40 permit ospf host 192.168.3.1 host 224.0.0.6
 50 permit ospf host 192.168.3.2 host 192.168.3.1
 60 permit ospf host 192.168.3.1 host 192.168.3.2
 70 deny   ospf any any
 80 permit ip any any
exit
!
interface Gi0/1
 ip access-group OSPF_R2_R1 in
exit
!
ip access-list extended OSPF_R2_R3
 10 permit ospf host 192.168.5.1 host 224.0.0.5
 20 permit ospf host 192.168.5.2 host 224.0.0.5
 30 permit ospf host 192.168.5.1 host 224.0.0.6
 40 permit ospf host 192.168.5.2 host 224.0.0.6
 50 permit ospf host 192.168.5.1 host 192.168.5.2
 60 permit ospf host 192.168.5.2 host 192.168.5.1
 70 deny   ospf any any
 80 permit ip any any
exit
!
interface Gi0/0
 ip access-group OSPF_R2_R3 in
exit
!
end
wr
```

R3

```bash
conf t
!
ip access-list extended OSPF_R3_R2
 10 permit ospf host 192.168.5.1 host 224.0.0.5
 20 permit ospf host 192.168.5.2 host 224.0.0.5
 30 permit ospf host 192.168.5.1 host 224.0.0.6
 40 permit ospf host 192.168.5.2 host 224.0.0.6
 50 permit ospf host 192.168.5.1 host 192.168.5.2
 60 permit ospf host 192.168.5.2 host 192.168.5.1
 70 deny   ospf any any
 80 permit ip any any
exit
!
interface Gi0/1
 ip access-group OSPF_R3_R2 in
exit
!
end
wr
```

SW1

```bash
conf t
!
ip access-list extended NO_OSPF_ON_SVIs
 deny   ospf any any
 permit ip any any
exit
!
interface vlan 10
 ip access-group NO_OSPF_ON_SVIs in
exit
!
interface vlan 20
 ip access-group NO_OSPF_ON_SVIs in
exit
!
interface vlan 1
 ip access-group NO_OSPF_ON_SVIs in
exit
!
end
wr
```

Command Breakdown:

- `ACLs on P2P Connections`: permitting OSPF hellos, DB/LAS to DR/BDR, and unicast neighbor exchanges between the exact P2P IPs; deny all other OSPF messages.
- `Inbound on P2P`: Filters OSPF at the edge of each router interface.
- `Block on user SVIs`: Deny OSPF arriving from hosts and allow normal IP exchange.

**Verify**

```bash
clear access-list counters
clear ip ospf process
[yes]
show ip ospf neighbor
show ip route ospf
show access-lists
```

Once we’ve verified that OSPF is working and adjacencies are working within our permits, we should be good to go. If you run into any issues like I did, double-check P2P IPs in the OSPF ACL, as well as permitting multicast hellos + unicast OSPF. Next up is DHCP Security!

### DHCP Security

Securing DHCP is important with an ACL because it allows normal client to server broadcast information to reach the SVI (either the SVI is the server or you’d use `ip helper-address` to it). Regardless, the ACL helps route DHCP traffic and prevents other routed DHCP traffic from transiting the SVI. Let’s take a look at the configuration:

**SW1, VLAN 10**

```bash
conf t
!
ip access-list extended DHCP_ONLY_V10
 remark Allows client broadcasts and SVI replies; block any rogue DHCP servers
 permit udp any eq 68 any eq 67
 permit udp host 192.168.10.1 eq 67 any eq 68
 deny   udp any eq 67 any
 permit ip any any
exit
!
interface vlan 10
 ip access-group DHCP_ONLY_V10 in
exit
!
end
wr
```

**SW1, VLAN 20**

```bash
conf t
!
ip access-list extended DHCP_ONLY_V20
 remark Allows client broadcasts and SVI replies; block any rogue DHCP servers
 permit udp any eq 68 any eq 67
 permit udp host 192.168.20.1 eq 67 any eq 68
 deny   udp any eq 67 any
 permit ip any any
exit
!
interface vlan 20
 ip access-group DHCP_ONLY_V20 in
exit
!
end
wr
```

Command breakdown:

- `permit udp any eq 68 any eq 67`: Client to server communication, DHCP Discover/Request contact the SVI.
- `deny udp any eq 67 any`: Drops the client to server communication, preventing any foreign DHCP from traversing the SVI.
- `permit ip any any`: Doesn’t stop non-DHCP traffic.

**Verify**

```bash
clear access-list counters
show access-lists DHCP_ONLY_V10
show access-lists DHCP_ONLY_V20
```

- From the Ubuntu or Windows VMs, apply these commands and then check the DHCP_ONLY ACL to see matches on the permit line:
    - Ubuntu: `sudo dhclient -r && sudo dhclient`
    - Windows: `ipconfig /release` then `ipconfig /rene`

Although DHCP ACLs cover the L3 aspect of preventing DHCP traffic outside subnets, DHCP Spoofing and Dynamic ARP Inspection cover the L2 security of this concept later in the lab. Last up, DNS filtering to force the Ubuntu VM’s DNS server only.

### DNS Filtering

Lastly, let’s create an ACL to force clients to use the `192.168.10.12` (Ubuntu VM) and then block any external DNS anywhere else. For this ACL, we’ll apply an outbound ACL on the client’s egress SVIs (VLAN 20 and MGMT VLAN 99). This way, replies won’t be filtered here.

**SW1**

```bash
conf t
!
ip access-list extended DNS_ENFORCE
remark Only allow DNS to 192.168.10.12 (Ubuntu)
 permit udp any host 192.168.10.12 eq 53
 permit tcp any host 192.168.10.12 eq 53
 deny   udp any any eq 53
 deny   tcp any any eq 53
 permit ip any any
exit
!
interface vlan 20
 ip access-group DNS_ENFORCE out
exit
!
interface vlan 99
 ip access-group DNS_ENFORCE out
exit
!
end
wr
```

Command Breakdown:

- The Ubuntu VM is our DNS server, so other clients trying to ping `8.8.8.8` will see a denies instead.
- This blocks classic DNS on TCP/UDP 53; however, it won’t block HTTPS.

**Verify**

- From VLAN 20 Host:
    - `nslookup google.com 192.168.10.12` : This should work normally.
    - `nslookup google.com 8.8.8.8` : This will either time out or be blocked.

On SW1:

- `clear access-list counters`
- Then run `show ip access-lists DNS_ENFORCE`
    - You should see hits on the permit line when querying the Ubuntu VM `192.168.10.12`
    - While seeing hits on the `deny eq 53` lines when trying to ping `8.8.8.8`

# SNMP, NTP, and Syslog Monitoring

In Network Engineering we not only want to configure devices to run complex dynamic routing, but we also want our devices to be their own administrators. To do this, we need to configure our devices to notify administrators about major and not-so major events that they experience. Not only that, but also be able to save that information, allow us to refer back to it, and manage their systems effectively.

In this lab, we will cover the last bit of the CCNA’s IP Services: **Simple Network Management Protocol (SNMP)**, **Network Time Protocol (NTP)**, and **System Message Logging (Syslog)**. These concepts allow engineers/administrators to be able to view the health and monitor an IP-based network, set the universal time on network devices, and see how/when changes were made on the network (and who did them) to save them for viewing later.

We will go through each concept, go into detail of why we need them, and configure them on the homelab:

1. **What is Network Monitoring?**
2. **Simple Network Management Protocol (SNMP)**
3. **Network Time Protocol (NTP)**
4. **System Message Logging (Syslog)**
5. **Wrap-Up**

Last lab on this homelab! Let’s finish up strong.

## What is Network Monitoring?

As the name implies, network monitoring involves the ongoing overseeing of the health, performance, reliability and security of networking equipment, both the hardware and the software.

Without it, we would have a difficult time knowing exactly if something went wrong, if someone who wasn’t allowed tried to login, and a record of what happened on devices.

There are three major protocols we use to provide observability for us:

1. **SNMP** - Alerts us on device health, interface status, and traffic patterns.
2. **NTP** - Synchronizes time across computers to offer precise time for accuracy.
3. **Syslog** - Logs system activities for security, errors, management, troubleshooting, etc.

These are relatively basic concepts for the CCNA, but they’re incredibly important for enterprise networks and operations. Let’s look at each of them individually.

## Simple Network Management Protocol (SNMP)

The idea around SNMP is being able to take information about TCP/IP devices like configurations settings, status information, counters, etc. into a database of all of these variables.

### Overview

Monitoring tools like SolarWinds, PRTG, and Cisco Prime all read these variables with SNMP to then display that for an admin, analyst, or an engineer.

- **Network Management Systems (NMS)**: Collects information from devices and helps display that in a meaningful way.

Here’s an example of SolarWinds’s dashboard and all of the graphs/charts it’ll utilize:

<center>
  <img width="400" height="400" alt="solarwinds" class="center" src="https://github.com/user-attachments/assets/b727c959-e0c2-4404-a2b7-1766ae73d98c" />
</center>

SNMP defines specific request/response messages between SNMP Managers and SNMP Clients:

- **SNMP Managers**: A network management application, usually running on a server, called a Network Management System (NMS).
- **SNMP Agents**: Software running on the device with knowledge of its variables to describe the device’s status.
- **Management Information Base (MIB)**: This is the database of all of their variables, that contain parameters, statuses, and counters.

To put it simply, an SNMP Manager will communicate with a SNMP Client to gain their MIB that contains their variables.

### SNMP Versions

To understand the different versions of SNMP, it’s a good idea to know the messages SNMP sends/receives:

- **SNMP Get**: A request asking for information from an agent
- **SNMP Set**: A request to set variables on the SNMP agent to configure the device.

The Original **SNMPv1** only had two Get request types: **Get** and **GetNext**. These requests were either a list of variables or a specific variable. SNMP Version 2 (**SNMPv2**) added the **GetBulk** request that would essentially be able to ask for a bulk request of variables from multiple devices, instead of just one. SNMP Version 3 (**SNMPv3**) takes this even a step further with adding security to these requests, securing the whole process with encryption.

For configuration of SNMP in this lab, we’ll use SNMPv3, which is the most secure and modern version of SNMP.

### SNMP Configuration

For this SNMP configuration, we will make all of the devices SNMP Agents, using SNMPv3, but we won’t set up the SNMP manager. Just to make it easier, so I don’t need to hook up my VMs each time. This is more than enough for the Cisco CCNA, so let’s get started!

**SW1 (Collector)**

```bash
conf t
!
snmp-server group MONITORS v3 priv
!
snmp-server user daniel MONITORS v3 auth sha StrongPass123 priv aes 128 StrongPass123
!
end
wr
```

Command Breakdown:

- `snmp-server group MONITORS v3 priv`: Creation of the SNMPv3 secure group.
- `snmp-server user…`: Creates a user in the SNMPv3 secure group with SHA & AES128 encryption.

**SW2, SW3, R1, R2, and R3 (SNMP Agents)**

```bash
conf t
!
snmp-server group MONITORS v3 priv
snmp-server user daniel MONITORS v3 auth sha <REDACTED> priv aes 128 <REDACTED>
!
snmp-server host 192.168.1.1 version 3 priv daniel
snmp-server enable traps
!
end
wr
```

Command Breakdown:

- `snmp-server host…`: Sends any traps from these devices to SW1.

**Verify**

```bash
show snmp
show snmp user
show snmp group
show snmp engineID
show snmp sessions
show snmp host
```

With this output, you should see the SNMP basic engine information as well as the configurations of each. 

## Network Time Protocol (NTP)

Every network device has its own clock, which is susceptible to drifting, which can cause devices to be on different times. To fix this, NTP synchronizes device clocks to a single universal reference.

### Overview

One of the most important use cases for NTP is accurate log timestamps, which display the time, date, and event information. Keeping them consistent with other devices helps with referencing during important device events. Furthermore, it’s important to understand how NTP goes about with synchronizing devices:

- **NTP Client**: Receives it’s synchronized time from the NTP master.
- **NTP Server**: The authoritative NTP server that other devices synchronize to.

Once an NTP client synchronizes with the NTP master, they can keep that time reference during almost anything, even periods of power loss. 

### NTP Client/Server Configuration

For my homelab, we will make SW1 our NTP server, that all other devices in my homelab will point to in order to get their correct time. Here’s how we’ll configure everything:

**SW1 (NTP Server)**

```bash
conf t
!
ntp master 3
!
end
wr
```

Command Breakdown:

- `ntp master 3`: Makes SW1 the NTP server with stratum 3.

**SW2, SW3, R1, R2, and R3**

```bash
conf t
!
ntp server 192.168.1.2 prefer
!
end
wr
```

Command Breakdown:

- `ntp server 192.168.1.2 prefer`: Adding an NTP server to the device by pointing to as the preferred clock synchronization.

**Verify**

```bash
show clock
show ntp status
show ntp associations
```

- You should see that the clock is synchronized between devices and SW1 is the NTP master

With NTP up now, all timestamps for logs, debugs, and syslog in the lab will all be lined up. With that out of the way, let’s move onto our last concept in the lab: syslog.

## System Message Logging (Syslog)

Syslog is the lifeblood of networking devices; log messages allow devices to record and send events - interface flaps, configuration changes, ACL hits, etc.

### Overview

Log messages are typically sent to a user logged into the device, where the CLI shows these messages as they occur. However, what happens when no one is logged in? We won’t know any potential issues that are going on in the device.  We’d need further configuration to have those logs sent somewhere else, and there are two ways we can do that:

- **Terminal Monitor**: Allows a device that configures this to receive log messages from another device.
- **Syslog Server**: Stores all log messages centrally from the network.

It’s more useful to have a syslog server, especially for an enterprise network, so logs are consistently forwarded to a secure and central place.

### Logging Levels

To make sense of the different cases for logs, IOS assigns each message a severity level, where a lower number indicates a more severe event.

Here’s a chart on all of the different severity cases with IOS:

| Level | Name | Description | Classification |
| --- | --- | --- | --- |
| 0 | emergencies | System unusable | Severe |
| 1 | alerts | Immediate action | Severe |
| 2 | critical | Critical conditions | Impactful |
| 3 | errors | Error conditions | Impactful |
| 4 | warnings | Warning conditions | Impactful |
| 5 | notifications | Normal but significant | Normal |
| 6 | informational | Informational messages | Normal |
| 7 | debugging | Debug-level messages | Debug |
- `0-1`: The most severe cases, and where serious or immediate issues are happening.
- `2-4`: Issues that impact a specific device, and aren’t as severe. Need to be watched.
- `5-6`: Messages that are notifying the user instead of identifying errors.
- `7`: Asks IOS to monitor internal events and to state them.

### Log Management Configuration

For logging, it’s a good idea before we configure our setup to configure exactly how we want our log messages to display. Changing the formatting on all of the devices would be a good idea for readability.

**SW1, SW2, SW3, R1, R2, and R3**

```bash
conf t
!
service timestamps log datetime msec localtime show-timezone
service timestamps debug datetime msec localtime show-timezone
!
service sequence-numbers
!
logging origin-id hostname
!
clock timezone MST -7
clock summer-time MDT recurring
!
end
wr
```

Command Breakdown:

- `log and debug timestamps`: This just saves the local time and date with logs and debugging.
- `service sequence-numbers`: Adds sequence numbers to log messages.
- `logging origin-id hostname`: Identifies devices by their hostname in the logs.

I set the time zone for `MST -7`, which is the time zone I live. You can make similar changes based on where you live.

### Logging Configuration

In a more realistic case, log messages would be sent to a syslog server, which keeps all of the logs from the devices. In my case, similar to the SNMP Manager, it might be easier to not include this configuration so I don’t need to hook up my VMs each time to my homelab. 

SW1 will be our log collector, so the other devices will send their logs to it, although SW1 does not store logs long-term. Let’s see how this is configured:

**SW1 (Collector)**

```bash
conf t
!
logging buffered 128000 informational
!
no logging console
!
end
wr
```

Command Breakdown:

- `logging buffered 128000 informational`: Be able to see it’s own logs as well as remote syslog messages from other devices.
- `no logging console`: Removes logs from the device to not spam the switch with other devices’ logs.

**SW2, SW3, R1, R2, and R3**

```bash
conf t
!
logging buffered 64000 informational
!
logging host 192.168.1.1
logging trap informational
service timestamps log datetime msec
!
no logging console
!
end
wr
```

Command Breakdown:

- `logging buffered 64000 informational`: Reasonable log buffer for local device logs.
- `logging host 192.168.1.1`: Sends logs to SW1.
- logging trap informational: Sends only messages of level “informational” and above (no debug messages).

**Verify**

```bash
show logging
```

- Check SW1 to see incoming logs from it’s own device and others in the homelab.

With that, we have successfully added logging to the home lab!

## Wrap-Up

Being able to configure IP services, specifically SNMP, NTP, and syslog, helps both network engineers and network administrators know the status of a device, the time it recorded a change, and how an outage occurred. NTP synchronizes the time for logging to be accurate, a syslog server is a central repository for those logs with the correct time, and SNMP Managers utilize logs to know how devices are doing; they work in congruence with one another. Each of these protocols benefit the other and ultimately benefits the network and those responsible for it.

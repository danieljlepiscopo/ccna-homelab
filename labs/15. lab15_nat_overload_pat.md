# NAT/NAT Overload (PAT) Simulation

If you’ve ever looked at the IP address of your device (PC, tablet, phone) at home, you’ve probably recognized that your IP address looks something like: `192.168.X.X`, `172.16.X.X`, or `10.X.X.X`.  This is because when you connect to your home modem, your ISP assigns a **public IP address** that allows you to access the internet. However, all the devices in your home network will have **private IP addresses**.

This is how **Network Address Translation (NAT)** behaves in real-life networks, and how IPv4 address conservation was utilized in the 1990s and 2000s. In this lab, we will explore NAT, how inside local (private) addresses reach external (public) networks, and configure the three different forms of NAT in the homelab: **Static NAT**, **Dynamic NAT**, and **NAT Overload (PAT)**. 

We’ll add, verify, and remove Static and Dynamic NAT, then enable and keep NAT Overload (PAT) as the final configuration on the homelab, since it’s the standard today. Let’s get started!

## Topology for NAT

Before we configure anything, let’s have an idea of how we should configure NAT logically in the homelab. Typically, you’d want to have NAT on the router that connects to the WAN (Internet), but in my case, I’m not going to have my homelab on the Internet. So, we’ll need to simulate NAT on router R1, which will connect to our “internal” LAN (VLANs 10/20/99 on SW1) as well as the external “Internet” router R2.

Here’s a chart of what I’m thinking:

| Device | Interface | IP Address | Role |
| --- | --- | --- | --- |
| R1 | Gi0/1 | 192.168.1.2/24 | Inside Local (to SW1/LAN) |
| R1 | Gi0/0 | 192.168.3.1/30 | Inside Global (to R2/ISP) |
| R2 | Gi0/1 | 192.168.3.2/30 | “ISP” / “Internet” |
| Ubuntu VM | NIC | 192.168.10.12/24 | Internal Host (VLAN 10) |
- Our inside LAN will be R1’s Gi0/1, while our outside will be on R1’s Gi0/0, and R2’s Gi0/1 will be considered the “ISP” or “Internet”.

NAT can become overwhelming, and misconfigurations can happen easily because of this. Now that we have our idea of how NAT will function in the homelab, we can go ahead and get started with configuring Static NAT.

## Static NAT

To get started with Static NAT, we’re going to need to use this configuration to get it up and running:

- `ip nat inside`: configure the inside part of the NAT design.
- `ip nat outside`: configure the outside part of the NAT design.
- `ip address *address mask*`: configure the subnet inside the global (public) address.
- `ip nat inside source static *inside-local inside-global*`: configure the static mappings.

For our inside/outside mapping, we’re going to need to create some IPs to use for this:

- `192.168.10.50` = **Inside Local**
    - A pretend server/host on SW1 (let’s say VLAN 10), that doesn’t exist on my homelab, but will help us demonstrate NAT in this lab.
- `192.168.3.10` = **Inside Global**
    - Our “public” or external-facing address that “outside” devices (R2 and R3) see when they reach this host.

Now that we have our steps when it comes to setting up basic static NAT connectivity, here are the steps we will take with configuring, verifying, removing, and concluding this section of the lab:

1. **Configure/Verify Static NAT**
2. **Remove Static NAT**
3. **Static NAT Conclusion**

### Configure/Verify Static NAT

Let’s take a look at the configuration and verification for this:

**R1**

```bash
conf t
!
interface GigabitEthernet0/1
  ip nat inside
exit
!
interface GigabitEthernet0/0
  description Downlink to WAN R2 Gi0/1 (ISP)
	ip nat outside
exit
!
ip route 0.0.0.0 0.0.0.0 192.168.3.2
!
ip nat inside source static 192.168.10.50 192.168.3.10
!
end
wr
```

Command Breakdown:

- `ip nat inside`: Marks Gi0/1 as the inside local interface.
- `ip nat outside`: Marks Gi0/0 as the outside local interface.
- `ip route 0.0.0.0 0.0.0.0 192.168.3.2`: Default route on R1 toward our “ISP”.
- `ip nat inside source static 192.168.10.50 192.168.3.10`: Static mapping between the inside host `192.168.10.50` (internal private IP) and the global outside IP `192.168.3.10`.

**R2**

```bash
conf t
!
ip route 192.168.3.10 255.255.255.255 192.168.3.1
!
end
wr
```

Command Breakdown:

- `ip route 192.168.3.10 255.255.255.255 192.168.3.1`: R2 knows how to reach the NAT pool/translated addresses via R1.

**Verify**

**R1**

```bash
show ip route
show ip nat translations
show ip nat statistics
```

**R2**

```bash
show ip route
ping 192.168.3.10 source 192.168.3.2
```

Once we’ve verified that NAT is configured and we’re seeing both the inside local, inside global, and active translations between the two routes (hits). We’ve officially configured Static NAT!

### **Remove Static NAT**

Since we’re only removing one mapping for Static NAT, this is a pretty easy configuration removal:

R1

```bash
conf t
!
no ip nat inside source static 192.168.10.50 192.168.3.10
!
end
wr
```

**R2**

```bash
conf t
!
no ip route 192.168.3.10 255.255.255.255 192.168.3.1
!
end
wr
```

- We’ll keep the `ip nat inside`, `ip nat outside`, and static route configurations, since they apply to the other NAT configurations.

### **Static NAT Conclusion**

Static NAT is similar to how static IP routes are configured. We aren’t conserving IPv4 space with static NAT IPs between the Inside Local and Outside Global, similar to how static IP routes can’t continually update without manual routes added. Obviously, this hinders scalability, so we’ll need a way for NAT to dynamically learn private/public IP addresses and be able to pull IPs from a NAT pool to then apply to packets that are trying to traverse the inside/outside barrier.

Let’s take a look at Dynamic NAT next to see how this works!

## Dynamic NAT

As we move on to Dynamic NAT, keep this in mind: we still aren’t conserving IP address space. Dynamic NAT dynamically creates NAT table entries, adding some protection against attackers. However, similarly to Static NAT, the NAT router still creates a one-to-one mapping between the inside local and inside global addresses. 

Similar to Static NAT, there are specific configuration steps we’ll need to accomplish for R1:

- `NAT ACL`: ACL that the packets entering the inside interface that the router should apply NAT.
- `ip nat pool name *first-address last-address* {netmask *subnet-mask* | prefix-length *length* }`: Configures the pool of public IP addresses to use.
- `ip nat inside source list *acl-number* pool *pool-name*`: Enables dynamic NAT, referencing the ACL and address pool.

Let’s see the configuration differences between Static and Dynamic NAT:

1. **Configure/Verify Dynamic NAT**
2. **Remove Dynamic NAT**
3. **Dynamic NAT Conclusion**

### **Configure/Verify Dynamic NAT**

Let’s take a look at the configuration and verification for this:

**R1**

```bash
conf t
!
ip nat pool DYNAMIC_POOL 209.165.200.20 209.165.200.30 netmask 255.255.255.0
access-list 1 permit 192.168.10.0 0.0.0.255
ip nat inside source list 1 pool DYNAMIC_POOL
!
end
wr
```

Command Breakdown:

- `ip nat pool DYNAMIC_POOL 209.165.200.20 209.165.200.30 netmask 255.255.255.0`: Our public addresses from `209.165.200.20` - `209.165.200.30`, for 10 private internal hosts.
- `access-list 1 permit 192.168.10.0 0.0.0.255`: Permitting addresses that are allowed to use the public addresses.
- `ip nat inside source list 1 pool DYNAMIC_POOL`: Enabled dynamic NAT and references the ACL and address pool.

**R2**

```bash
conf t
!
ip route 209.165.200.0 255.255.255.0 192.168.3.1
!
end
wr
```

Command Breakdown:

- `ip route 209.165.200.0 255.255.255.0 192.168.3.1`: R2 knows how to reach the NAT pool/translated addresses via R1.

**Verify**

**Ubuntu VM**

```bash
ping 209.165.200.2
```

**R1**

```bash
show ip nat translations
show ip nat statistics
```

**R2**

```bash
show ip route
```

If you don’t see translations, generate traffic from a client. Try and ping an outside IP, and the output should look something like this:

```bash
R1#show ip nat translations
Pro Inside global         Inside local          Outside local         Outside global
--- 209.165.200.20        192.168.10.12         ---                   ---
```

Here you can see that we’re using a pool of addresses for our internal hosts. Mapping each host to a public IP address in the pool, however, is limited to the number of the pool (10).

### **Remove Dynamic NAT**

Let’s go ahead and remove the configuration we just set for dynamic NAT:

**R1**

```bash
conf t
!
no ip nat inside source list 1 pool DYNAMIC_POOL
no ip nat pool DYNAMIC_POOL
!
end
wr
```

**R2**

```bash
conf t
!
no ip route 209.165.200.0 255.255.255.0 192.168.3.1
!
end
wr
```

- We’ll end up reusing the ACL 1 for NAT Overload (PAT) configuration, so please don’t remove it.

### **Dynamic NAT Conclusion**

Keep in mind, with Dynamic NAT, in an enterprise setting, a NAT pool will typically contain fewer addresses than the total number of hosts inside the enterprise. Meaning, if new packets arrive, triggering a need for a NAT table entry, but there are no more IP addresses in the pool, the router will just discard the packets, which is NOT good. Pool exhaustion will silently drop flows until an address frees up. To combat this, what if we had unlimited host addresses for the inside local? No pool or limit required. That’s where NAT Overload (PAT) comes into play!

## NAT Overload (PAT)

The NAT Overload feature, also called **Port Address Translation (PAT)**, will actually reduce the number of IPv4 public addresses. Static NAT and Dynamic NAT have been a one-to-one mapping, but with NAT Overload (PAT), we only need one single public IP address, while having unlimited private IP addresses in our own network. PAT does this by using the transport layer, adding port numbers to the private IP addresses, allowing for traversal between inside local and inside global.

Here are the specific configuration steps we’ll need to accomplish for NAT Overload (PAT) to work:

- `ip nat inside source list *acl-number* interface *type/number* overload`: Global configuration refers to the ACL from Dynamic NAT, and which interface connects to the

Let’s see how it’s configured:

1. **Configure/Verify NAT Overload (PAT)**
2. **Remove NAT Overload (PAT)**
3. **NAT Overload (PAT) Conclusion**

### **Configure/Verify NAT Overload (PAT)**

Let’s take a look at the configuration and verification for this:

**R1**

```bash
conf t
!
ip nat inside source list 1 interface GigabitEthernet0/0 overload
!
end
wr
```

Command Breakdown:

- `ip nat inside source list 1 interface GigabitEthernet0/0 overload`: Using ACL 1 to tell R1 that the interface Gi0/0 will be “overload” to enable NAT Overload (PAT)

**Verify**

```bash
show ip nat translations
show ip nat statistics
```

- Again, if you don’t see any translations, use a client device to ping outside the internal.

That’s it! Pretty easy, right? You should now see port numbers appended to the IPs in the translation table:

```bash
R1#show ip nat translations
Pro Inside global      Inside local       Outside local      Outside global
icmp 192.168.3.1:3467  192.168.10.12:3467 192.168.4.1:3467   192.168.4.1:3467
```

- With PAT, inside local IPs share the outside-interface IP, differing by the different port numbers.

We will not remove NAT Overload (PAT) from the homelab, but rather keep it as a simulated concept of PAT.

### **NAT Overload (PAT) Conclusion**

Without NAT Overload (PAT), IPv4 addresses would have been even more exhausted way before the foundational idea of IPv6 was even conceived. NAT Overload (PAT) saved IPv4, the internet, and the completion of IPv6, as we now move forward with the eventual takeover of IPv6. When that day comes about, no one actually knows, but in the meantime, IPv4 is here to stay with NAT.

## Wrap-Up

NAT is such a universal IP service, similar to DHCP and DNS; without it, we probably would not have the internet. I would even argue that NAT is just as important, if not more important, than a lot of the IP services because of this. It’s easy to ignore how imperative it was for the conservation of IPv4, that we use NAT every day in our lives without even really realizing it. Networks today, enterprise networks, rely on NAT between them and the internet, as well as Internet Service Providers (ISPs), giving us and everyone an IPv4 address to get onto the internet.
